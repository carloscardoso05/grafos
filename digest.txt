Directory structure:
└── grafos/
    ├── pom.xml
    └── src/
        ├── main/
        │   └── java/
        │       └── grafo/
        │           ├── Aresta.java
        │           ├── Grafo.java
        │           ├── Main.java
        │           ├── Vertice.java
        │           ├── digrafo/
        │           │   ├── Digrafo.java
        │           │   └── DigrafoPorLista.java
        │           ├── nao_orientado/
        │           │   ├── GrafoNaoDirecionado.java
        │           │   └── GrafoNaoDirecionadoPorLista.java
        │           └── util/
        │               └── Fleury.java
        └── test/
            └── java/
                ├── ArestaTest.java
                ├── DigrafoTest.java
                ├── FleuryTest.java
                ├── GrafoNaoDirecionadoTest.java
                ├── GrafoTest.java
                ├── MainTest.java
                ├── Provider.java
                └── VerticeTest.java

================================================
File: pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>cardoso.carlos</groupId>
    <artifactId>grafos</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>24</maven.compiler.source>
        <maven.compiler.target>24</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.junit</groupId>
                <artifactId>junit-bom</artifactId>
                <version>5.13.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>5.13.0</version>
            <scope>test</scope>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.google.guava/guava -->
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>33.4.8-jre</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.5.3</version>
            </plugin>
        </plugins>
    </build>

</project>


================================================
File: src/main/java/grafo/Aresta.java
================================================
package grafo;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import com.google.common.base.Strings;

import java.util.function.UnaryOperator;

public record Aresta(String label, Vertice origem, Vertice destino, double peso) {
	public Aresta(String label, Vertice origem, Vertice destino) {
		this(label, origem, destino, 0);
	}

	public Aresta {
		checkArgument(!Strings.isNullOrEmpty(label), "RÃ³tulo da aresta nÃ£o pode ser nulo ou vazio");
		checkNotNull(origem, "VÃ©rtice de origem nÃ£o pode ser nulo");
		checkNotNull(destino, "VÃ©rtice de destino nÃ£o pode ser nulo");
	}

	public Aresta inversa() {
		return new Aresta(label + "- inversa", destino, origem, peso);
	}

	public boolean mesmoLabel(Aresta outra) {
		return this.label.equals(outra.label);
	}

	/**
	 * Verifica se a aresta tem o mesmo sentido que outra aresta.
	 * <br>
	 * O sentido Ã© considerado o mesmo se as arestas tiverem a mesma origem e
	 * destino.
	 * <br>
	 * Exemplo: A -> B Ã© o mesmo sentido que A -> B. A -> B nÃ£o Ã© o mesmo sentido
	 * que B -> A.
	 * 
	 * @param outra
	 * @return se as arestas tÃªm o mesmo sentido
	 * @see #mesmaDirecao(Aresta outra)
	 */
	public boolean mesmoSentido(Aresta outra) {
		return this.origem.equals(outra.origem) && this.destino.equals(outra.destino);
	}

	/**
	 * Verifica se a aresta Ã© inversa de outra aresta.
	 * <br>
	 * A aresta Ã© considerada inversa se a origem for o destino da outra e o
	 * destino for a origem da outra.
	 * <br>
	 * Exemplo: A -> B Ã© inversa de B -> A.
	 * 
	 * @param outra
	 * @return se as arestas sÃ£o inversas
	 */
	public boolean sentidoInverso(Aresta outra) {
		return this.origem.equals(outra.destino) && this.destino.equals(outra.origem);
	}

	/**
	 * Verifica se a aresta tem a mesma direÃ§Ã£o que outra aresta.
	 * <br>
	 * A direÃ§Ã£o Ã© considerada a mesma se as arestas tiverem as duas extremidades
	 * iguais, ou seja
	 * se o sentido for o mesmo ou se forem inversas.
	 * <br>
	 * Exemplo: A -> B Ã© a mesma direÃ§Ã£o que B -> A.
	 * 
	 * @param outra
	 * @return se as arestas tÃªm a mesma direÃ§Ã£o
	 * @see #mesmoSentido(Aresta outra)
	 * @see #inversa()
	 */
	public boolean mesmaDirecao(Aresta outra) {
		return mesmoSentido(outra) || sentidoInverso(outra);
	}

	public Aresta comLabel(String novoLabel) {
		checkArgument(!Strings.isNullOrEmpty(novoLabel), "RÃ³tulo da aresta nÃ£o pode ser nulo ou vazio");
		return new Aresta(novoLabel, origem, destino, peso);
	}

	public Aresta comLabel(UnaryOperator<String> funcaoLabel) {
		checkNotNull(funcaoLabel, "FunÃ§Ã£o de rÃ³tulo nÃ£o pode ser nula");
		return comLabel(funcaoLabel.apply(label));
	}

	public boolean ehLaco() {
		return origem.equals(destino);
	}

	@Override
	public final boolean equals(Object obj) {
		if (obj == null) {
			return false;
		}
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof Aresta outra)) {
			return false;
		}
		return mesmoLabel(outra);
	}

	@Override
	public final int hashCode() {
		return label.hashCode();
	}
}



================================================
File: src/main/java/grafo/Grafo.java
================================================
package grafo;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import com.google.errorprone.annotations.CanIgnoreReturnValue;

import grafo.digrafo.Digrafo;
import grafo.nao_orientado.GrafoNaoDirecionado;

public abstract class Grafo {
	protected static final String MSG_VERTICE_NULO = "VÃ©rtice nÃ£o pode ser nulo";
	protected static final String MSG_VERTICE_NAO_EXISTE = "VÃ©rtice nÃ£o existe no grafo";
	protected static final String MSG_ARESTA_NULA = "Aresta nÃ£o pode ser nula";
	protected static final String MSG_ARESTA_EXISTE = "Aresta jÃ¡ existe no grafo com o label informado";

	public abstract void addAresta(Aresta aresta);

	public final void addArestas(Aresta... arestas) {
		for (Aresta aresta : arestas) {
			addAresta(aresta);
		}
	}

	public abstract void removeAresta(String label);

	public final void removeArestas(String... labels) {
		for (String label : labels) {
			removeAresta(label);
		}
	}

	public final void removeAresta(Vertice origem, Vertice destino) {
		checkNotNull(origem, MSG_VERTICE_NULO);
		checkNotNull(destino, MSG_VERTICE_NULO);

		Aresta aresta = encontrarAresta(origem, destino);
		if (aresta != null) {
			removeAresta(aresta.label());
		}
	}

	public final void removeArestas(Vertice origem, Vertice destino) {
		checkNotNull(origem, MSG_VERTICE_NULO);
		checkNotNull(destino, MSG_VERTICE_NULO);

		String[] labels = encontrarArestas(origem, destino).stream()
														   .map(Aresta::label)
														   .toArray(String[]::new);
		removeArestas(labels);
	}

	/**
	 * Tenta encontrar uma aresta pelo seu label (rÃ³tulo).
	 * <br>
	 * Obs.: O label Ã© o identificador Ãºnico da aresta.
	 *
	 * @param label o rÃ³tulo da aresta
	 * @return a aresta com o label informado ou null se nÃ£o existir
	 */
	public final Aresta encontrarAresta(String label) {
		checkNotNull(label, MSG_ARESTA_NULA);

		return getArestas()
				.stream()
				.filter(aresta -> aresta.label().equals(label))
				.findFirst()
				.orElse(null);
	}

	/**
	 * Tenta encontrar uma aresta entre dois vÃ©rtices.
	 *
	 * @param origem
	 * @param destino
	 * @return a aresta entre os vÃ©rtices origem e destino ou null se nÃ£o existir
	 */
	public abstract Aresta encontrarAresta(Vertice origem, Vertice destino);

	/**
	 * Encontra todas as arestas entre o vÃ©rtice origem e o vÃ©rtice destino.
	 * <br>
	 * No caso de um grafo nÃ£o orientado, sÃ£o consideradas as arestas (origem ->
	 * destino) e tambÃ©m (destino -> origem).
	 * <br>
	 * No caso de um grafo orientado, sÃ£o consideradas apenas as arestas (origem ->
	 * destino).
	 *
	 * @param origem
	 * @param destino
	 * @return um conjunto de arestas entre os vÃ©rtices origem e destino
	 */
	public abstract Set<Aresta> encontrarArestas(Vertice origem, Vertice destino);

	@CanIgnoreReturnValue
	public abstract Vertice addVertice(Vertice vertice);

	@CanIgnoreReturnValue
	public final Vertice[] addVertices(Vertice... vertices) {
		for (Vertice vertice : vertices) {
			addVertice(vertice);
		}
		return vertices;
	}

	public abstract void removeVertice(Vertice vertice);

	public final void removeVertices(Vertice... vertices) {
		for (Vertice vertice : vertices) {
			removeVertice(vertice);
		}
	}

	/**
	 * Verifica se uma aresta com o label (rÃ³tulo) existe no grafo.
	 * <br>
	 * Obs.: O label Ã© o identificador Ãºnico da aresta.
	 *
	 * @param label o rÃ³tulo da aresta
	 * @return se a aresta existe no grafo
	 */
	public final boolean existeAresta(String label) {
		checkNotNull(label, MSG_ARESTA_NULA);
		return encontrarAresta(label) != null;
	}

	/**
	 * Verifica se existe alguma aresta entre os vÃ©rtices origem e destino.
	 * <br>
	 * No caso de um grafo nÃ£o orientado, a sÃ£o consideradas as arestas (origem ->
	 * destino) e tambÃ©m (destino -> origem).
	 * <br>
	 * No caso de um grafo orientado, sÃ£o consideradas apenas as arestas (origem ->
	 * destino).
	 *
	 * @param origem
	 * @param destino
	 * @return se existe uma aresta entre os vÃ©rtices origem e destino
	 */
	public final boolean existeAresta(Vertice origem, Vertice destino) {
		checkNotNull(origem, MSG_VERTICE_NULO);
		checkNotNull(destino, MSG_VERTICE_NULO);

		return encontrarAresta(origem, destino) != null;
	}

	/**
	 * Verifica se existe um vÃ©rtice no grafo.
	 *
	 * @param vertice
	 * @return se o vÃ©rtice existe no grafo
	 */
	public final boolean existeVertice(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		return getVertices().contains(vertice);
	}

	public abstract Set<Aresta> getArestas();

	// public final abstract Set<Aresta> getArestas(Vertice vertice);

	/**
	 * Retorna um conjunto de arestas do grafo.
	 *
	 * @return conjunto de arestas do grafo
	 */
	public abstract Set<Vertice> getVertices();

	/**
	 * Retorna uma lista de vÃ©rtices que podem ser alcanÃ§ados a partir do vÃ©rtice
	 * informado.
	 * <br>
	 * No caso de um vÃ©rtice nÃ£o orientado, serÃ£o consideradas as arestas (vertice
	 * -> vizinho) e tambÃ©m (vizinho -> vertice).
	 * <br>
	 * No caso de um vÃ©rtice orientado, serÃ£o consideradas apenas as arestas
	 * (vertice -> vizinho).
	 *
	 * @param vertice
	 * @return lista de vÃ©rtices vizinhos do vÃ©rtice informado
	 */
	public final Set<Vertice> getAdjacentes(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		checkArgument(existeVertice(vertice), MSG_VERTICE_NAO_EXISTE);

		return getVertices()
				.stream()
				.filter(v -> existeAresta(vertice, v))
				.collect(Collectors.toSet());
	}

	/**
	 * Retorna um conjunto de vÃ©rtices que estÃ£o conectados ao vÃ©rtice informado.
	 * <br>
	 * SÃ£o considerados vÃ©rtices conectados aqueles que possuem pelo menos uma
	 * aresta conectando-os ao vÃ©rtice informado, como (vertice -> vizinho) ou (vizinho -> vertice).
	 *
	 * @param vertice
	 * @return conjunto de vÃ©rtices conectados ao vÃ©rtice informado
	 */
	public final Set<Vertice> getConectados(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		checkArgument(existeVertice(vertice), MSG_VERTICE_NAO_EXISTE);

		return getVertices()
				.stream()
				.filter(v -> existeAresta(vertice, v) || existeAresta(v, vertice))
				.collect(Collectors.toSet());
	}

	public abstract long getGrauDeEntrada(Vertice vertice);

	public abstract long getGrauDeSaida(Vertice vertice);

	/**
	 * Remove todos os vÃ©rtices e arestas do grafo, deixando-o vazio.
	 */
	public final void resetar() {
		removeVertices(getVertices().toArray(Vertice[]::new));
	}

	/**
	 * Cria uma cÃ³pia do grafo atual. Instancia um novo grafo e adiciona os mesmos
	 * vÃ©rtices e arestas.
	 *
	 * @return uma nova instÃ¢ncia do grafo com os mesmos vÃ©rtices e arestas
	 */
	public final Grafo clonar() {
		Grafo grafo = novaInstancia();
		for (Vertice vertice : getVertices()) {
			grafo.addVertice(vertice);
		}
		for (Aresta aresta : getArestas()) {
			grafo.addAresta(aresta);
		}
		return grafo;
	}

	protected abstract Grafo novaInstancia();

	public final boolean mesmoTipo(Grafo outroGrafo) {
		checkNotNull(outroGrafo, "Outro grafo nÃ£o pode ser nulo");
		boolean saoDigrafos = this instanceof Digrafo && outroGrafo instanceof Digrafo;
		boolean saoNaoOrientados = this instanceof GrafoNaoDirecionado && outroGrafo instanceof GrafoNaoDirecionado;
		return saoDigrafos ^ saoNaoOrientados;
	}

	@Override
	public final boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof Grafo grafo)) {
			return false;
		}
		if (!mesmoTipo(grafo)) {
			return false;
		}
		return getVertices().equals(grafo.getVertices()) && getArestas().equals(grafo.getArestas());
	}

	public final boolean temLaco() {
		return getArestas().stream().anyMatch(Aresta::ehLaco);
	}

	public final int componentesConexas() {
    Set<Vertice> visitados = new HashSet<>();
    int componentes = 0;

    for (Vertice v : getVertices()) {
        if (!visitados.contains(v)) {
            componentes++;
            // BFS completa a partir de v
            Deque<Vertice> fila = new ArrayDeque<>();
            fila.add(v);
            visitados.add(v);

            while (!fila.isEmpty()) {
                Vertice atual = fila.removeFirst();
                for (Vertice vizinho : getConectados(atual)) {
                    if (visitados.add(vizinho)) {
                        fila.add(vizinho);
                    }
                }
            }
        }
    }
    return componentes;
	}

	public final boolean ehConexo() {
		return componentesConexas() == 1;
	}

	public final boolean ehPonte(Aresta aresta) {
		checkNotNull(aresta, MSG_ARESTA_NULA);
		checkArgument(existeAresta(aresta.label()), "Aresta deve existir no grafo");

		Grafo grafoSemAresta = clonar();
		grafoSemAresta.removeAresta(aresta.label());

		return !grafoSemAresta.ehConexo();
	}

	public final boolean ehDisjunto(Grafo outroGrafo) {
		checkNotNull(outroGrafo, "Outro grafo nÃ£o pode ser nulo");
		Set<Vertice> outrosVertices = outroGrafo.getVertices();
		Set<Aresta> outrasArestas = outroGrafo.getArestas();
		boolean verticesDisjuntos = getVertices().stream().noneMatch(outrosVertices::contains);
		boolean arestasDisjuntas = getArestas().stream().noneMatch(outrasArestas::contains);
		return verticesDisjuntos && arestasDisjuntas;
	}

	@Override
	public final String toString() {
		String str = """
				%s {
					VÃ©rtices = { %s }
					Arestas = { %s }
				}""";
		return String.format(
				str,
				getClass().getSimpleName(),
				String.join(
						", ",
						getVertices().stream()
									 .map(Vertice::label)
									 .map(String::valueOf)
									 .toList()),
				String.join(
						", ",
						getArestas().stream()
									.map(aresta -> "(%s, %s)".formatted(aresta.origem().label(), aresta.destino()
																									   .label()))
									.toList()));
	}
}



================================================
File: src/main/java/grafo/Main.java
================================================
package grafo;

import grafo.nao_orientado.GrafoNaoDirecionadoPorLista;

public class Main {
	public static void main(String[] args) {
		Grafo grafo = new GrafoNaoDirecionadoPorLista();

		Vertice verticeA = new Vertice("A");
		Vertice verticeB = new Vertice("B");
		Vertice verticeC = new Vertice("C");
		Vertice verticeD = new Vertice("D");

		grafo.addVertice(verticeA);
		grafo.addVertice(verticeB);
		grafo.addVertice(verticeC);
		grafo.addVertice(verticeD);

		grafo.addAresta(new Aresta("AB", verticeA, verticeB));
		grafo.addAresta(new Aresta("BC", verticeB, verticeC));
		grafo.addAresta(new Aresta("CD", verticeC, verticeD));
		grafo.addAresta(new Aresta("DA", verticeD, verticeA));
		grafo.addAresta(new Aresta("AC", verticeA, verticeC));

		System.out.println(grafo);
	}
}



================================================
File: src/main/java/grafo/Vertice.java
================================================
package grafo;

import com.google.common.base.Strings;

import java.util.function.UnaryOperator;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

public record Vertice(String label) {
    public Vertice {
        checkArgument(!Strings.isNullOrEmpty(label), "RÃ³tulo do vÃ©rtice nÃ£o pode ser nulo ou vazio");
    }

    public Aresta formarAresta(String label, Vertice destino) {
        checkArgument(!Strings.isNullOrEmpty(label), "RÃ³tulo da aresta nÃ£o pode ser nulo ou vazio");
        return new Aresta(label, this, destino);
    }
}



================================================
File: src/main/java/grafo/digrafo/Digrafo.java
================================================
package grafo.digrafo;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import grafo.Aresta;
import grafo.Grafo;
import grafo.Vertice;

public abstract class Digrafo extends Grafo {

	@Override
	public final long getGrauDeEntrada(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		checkArgument(existeVertice(vertice), MSG_VERTICE_NAO_EXISTE);

		return getArestas()
				.stream()
				.filter(aresta -> aresta.destino().equals(vertice))
				.count();
	}

	@Override
	public final long getGrauDeSaida(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		checkArgument(existeVertice(vertice), MSG_VERTICE_NAO_EXISTE);

		return getArestas()
				.stream()
				.filter(aresta -> aresta.origem().equals(vertice))
				.count();
	}

	@Override
	public final Aresta encontrarAresta(Vertice origem, Vertice destino) {
		checkNotNull(origem, MSG_VERTICE_NULO);
		checkNotNull(destino, MSG_VERTICE_NULO);

		return getArestas()
				.stream()
				.filter(aresta -> aresta.origem().equals(origem) && aresta.destino().equals(destino))
				.findFirst()
				.orElse(null);
	}
}


================================================
File: src/main/java/grafo/digrafo/DigrafoPorLista.java
================================================
package grafo.digrafo;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import java.util.*;
import java.util.stream.Collectors;

import grafo.Aresta;
import grafo.Grafo;
import grafo.Vertice;

public class DigrafoPorLista extends Digrafo {
	private final Map<Vertice, List<Aresta>> verticesAdjacencias = new HashMap<>();

	@Override
	public void addAresta(Aresta aresta) {
		checkNotNull(aresta, MSG_ARESTA_NULA);
		checkArgument(!existeAresta(aresta.label()), MSG_ARESTA_EXISTE);

		Vertice origem = aresta.origem();
		Vertice destino = aresta.destino();

		addVertice(origem);
		addVertice(destino);

		verticesAdjacencias.get(origem).add(aresta);
	}

	@Override
	public Vertice addVertice(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		verticesAdjacencias.putIfAbsent(vertice, new ArrayList<>());
		return vertice;
	}

	@Override
	public void removeVertice(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);

		verticesAdjacencias.remove(vertice);

		for (List<Aresta> adjacencias : verticesAdjacencias.values()) {
			adjacencias.removeIf(aresta -> aresta.origem().equals(vertice) || aresta.destino().equals(vertice));
		}
	}

	@Override
	public Set<Aresta> getArestas() {
		return verticesAdjacencias.values().stream()
				.flatMap(List::stream)
				.collect(Collectors.toSet());
	}

	@Override
	public Set<Vertice> getVertices() {
		return verticesAdjacencias.keySet();
	}

	@Override
	public void removeAresta(String label) {
		checkNotNull(label, MSG_ARESTA_NULA);

		for (List<Aresta> adjacencias : verticesAdjacencias.values()) {
			adjacencias.removeIf(aresta -> aresta.label().equals(label));
		}
	}

	@Override
	public Set<Aresta> encontrarArestas(Vertice origem, Vertice destino) {
		return getArestas()
				.stream()
				.filter(aresta -> aresta.origem().equals(origem) && aresta.destino().equals(destino))
				.collect(Collectors.toSet());
	}

	@Override
	protected Grafo novaInstancia() {
		return new DigrafoPorLista();
	}
}



================================================
File: src/main/java/grafo/nao_orientado/GrafoNaoDirecionado.java
================================================
package grafo.nao_orientado;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import grafo.Aresta;
import grafo.Grafo;
import grafo.Vertice;

public abstract class GrafoNaoDirecionado extends Grafo {
	public final long getGrau(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		return getArestas().stream()
				.flatMap(aresta -> List.of(aresta.destino(), aresta.origem()).stream())
				.filter(vertice::equals)
				.count();
	}

	@Override
	public final long getGrauDeEntrada(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		return getGrau(vertice);
	}

	@Override
	public final long getGrauDeSaida(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		return getGrau(vertice);
	}

	@Override
	public final Set<Aresta> encontrarArestas(Vertice origem, Vertice destino) {
		return getArestas()
				.stream()
				.filter(aresta -> (aresta.origem().equals(origem) && aresta.destino().equals(destino)) ||
						(aresta.origem().equals(destino) && aresta.destino().equals(origem)))
				.collect(Collectors.toSet());
	}

	@Override
	public final Aresta encontrarAresta(Vertice origem, Vertice destino) {
		return encontrarArestas(origem, destino).stream().findFirst().orElse(null);
	}

	public final GrafoNaoDirecionado uniao(GrafoNaoDirecionado outroGrafo) {
		checkNotNull(outroGrafo, "Outro grafo nÃ£o pode ser nulo");
		checkArgument(ehDisjunto(outroGrafo), "Os grafos devem ser disjuntos para serem unidos");

		GrafoNaoDirecionado grafoUnido = (GrafoNaoDirecionado) clonar();
		grafoUnido.addVertices(outroGrafo.getVertices().toArray(Vertice[]::new));
		grafoUnido.addArestas(outroGrafo.getArestas().toArray(Aresta[]::new));
		return grafoUnido;
	}

	public final boolean ehEuleriano() {
		return getVertices().stream().allMatch(vertice -> getGrau(vertice) % 2 == 0);
	}

	public final boolean ehSemiEuleriano() {
		long verticesImpares = getVertices().stream()
				.filter(vertice -> getGrau(vertice) % 2 != 0)
				.count();
		return verticesImpares == 0 || verticesImpares == 2;
	}

	public final GrafoNaoDirecionado intersecao(GrafoNaoDirecionado outroGrafo) {
		throw new UnsupportedOperationException("A interseÃ§Ã£o de grafos nÃ£o direcionados ainda nÃ£o estÃ¡ implementada");
		// checkNotNull(outroGrafo, "Outro grafo nÃ£o pode ser nulo");

		// GrafoNaoDirecionado grafoIntersecao = (GrafoNaoDirecionado) novaInstancia();
		// Vertice[] vertices = getVertices().stream()
		// .filter(outroGrafo::existeVertice)
		// .toArray(Vertice[]::new);
		// grafoIntersecao.addVertices(vertices);
		// Aresta[] arestas = getArestas().stream()
		// .filter(aresta -> outroGrafo.existeAresta(aresta.origem(), aresta.destino()))
		// .toArray(Aresta[]::new);
		// return grafoIntersecao;
	}
}



================================================
File: src/main/java/grafo/nao_orientado/GrafoNaoDirecionadoPorLista.java
================================================
package grafo.nao_orientado;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import java.util.*;
import java.util.stream.Collectors;

import grafo.Aresta;
import grafo.Grafo;
import grafo.Vertice;

public class GrafoNaoDirecionadoPorLista extends GrafoNaoDirecionado {
	private final Map<Vertice, List<Aresta>> verticesAdjacencias = new HashMap<>();

	@Override
	public void addAresta(Aresta aresta) {
		checkNotNull(aresta, MSG_ARESTA_NULA);
		checkArgument(!existeAresta(aresta.label()), MSG_ARESTA_EXISTE);

		Vertice origem = aresta.origem();
		Vertice destino = aresta.destino();

		addVertice(origem);
		addVertice(destino);

		verticesAdjacencias.get(origem).add(aresta);
	}

	@Override
	public Vertice addVertice(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);
		verticesAdjacencias.putIfAbsent(vertice, new ArrayList<>());
		return vertice;
	}

	@Override
	public void removeVertice(Vertice vertice) {
		checkNotNull(vertice, MSG_VERTICE_NULO);

		verticesAdjacencias.remove(vertice);

		for (List<Aresta> adjacencias : verticesAdjacencias.values()) {
			adjacencias.removeIf(aresta -> aresta.origem().equals(vertice) || aresta.destino().equals(vertice));
		}
	}

	@Override
	public Set<Aresta> getArestas() {
		return verticesAdjacencias.values().stream()
				.flatMap(List::stream)
				.collect(Collectors.toSet());
	}

	@Override
	public Set<Vertice> getVertices() {
		return verticesAdjacencias.keySet();
	}

	@Override
	public void removeAresta(String label) {
		checkNotNull(label, MSG_ARESTA_NULA);

		for (List<Aresta> adjacencias : verticesAdjacencias.values()) {
			adjacencias.removeIf(aresta -> aresta.label().equals(label));
		}
	}

	@Override
	protected Grafo novaInstancia() {
		return new GrafoNaoDirecionadoPorLista();
	}
}



================================================
File: src/main/java/grafo/util/Fleury.java
================================================
package grafo.util;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.SequencedSet;

import grafo.Aresta;
import grafo.Vertice;
import grafo.nao_orientado.GrafoNaoDirecionado;

public class Fleury {
    private final GrafoNaoDirecionado grafo;
    private final Vertice verticeInicial;
    private final SequencedSet<Aresta> caminhoEuleriano = new LinkedHashSet<>();
    private Vertice verticeAtual;

    public List<Aresta> getCaminhoEuleriano() {
        return List.copyOf(caminhoEuleriano);
    }

    public Fleury(GrafoNaoDirecionado grafo, Vertice verticeInicial) {
        checkNotNull(grafo, "Grafo nÃ£o pode ser nulo");
        checkNotNull(verticeInicial, "VÃ©rtice inicial nÃ£o pode ser nulo");
        checkArgument(grafo.existeVertice(verticeInicial), "VÃ©rtice inicial existe no grafo");
        checkArgument(grafo.ehEuleriano(), "Grafo deve ser Euleriano para aplicar o algoritmo de Fleury");
        checkArgument(grafo.ehConexo(), "Grafo deve ser conexo para aplicar o algoritmo de Fleury");
        this.grafo = grafo;
        this.verticeInicial = verticeInicial;
        rodar();
    }

    private void rodar() {
        verticeAtual = verticeInicial;
        int qtdArestas = grafo.getArestas().size();
        while (caminhoEuleriano.size() < qtdArestas) {
            Aresta aresta = escolheAresta();
            verticeAtual = verticeAtual != aresta.destino() ? aresta.destino() : aresta.origem();
            caminhoEuleriano.add(aresta);
        }
    }

    private Aresta escolheAresta() {
        var vizinhos = grafo.getAdjacentes(verticeAtual);
        if (vizinhos.isEmpty()) {
            return null;
        }
        var arestasCandidatas = vizinhos
                .stream()
                .flatMap(v -> grafo.encontrarArestas(verticeAtual, v).stream())
                .filter(aresta -> !caminhoEuleriano.contains(aresta) && !grafo.ehPonte(aresta));

        return arestasCandidatas.findFirst().orElse(null);
    }
}



================================================
File: src/test/java/ArestaTest.java
================================================
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import org.junit.jupiter.api.Test;

import grafo.Aresta;
import grafo.Vertice;

public class ArestaTest {
    @Test
    void criarArestaTest() {
        assertThrows(NullPointerException.class, () -> {
            Vertice origem = new Vertice("A");
            new Aresta("A - null", origem, null);
        }, "Aresta com destino nulo deve lanÃ§ar NullPointerException");

        assertThrows(NullPointerException.class, () -> {
            Vertice destino = new Vertice("B");
            new Aresta("null - B", null, destino);
        }, "Aresta com origem nula deve lanÃ§ar NullPointerException");
    }

    @Test
    void arestaInversaTest() {
        Vertice origem = new Vertice("A");
        Vertice destino = new Vertice("B");
        Aresta aresta = new Aresta("AB", origem, destino);
        Aresta inversa = new Aresta("BA", destino, origem);

        assertTrue(aresta.sentidoInverso(inversa), "Aresta inversa deve ser igual Ã  aresta original invertida");
        assertTrue(aresta.sentidoInverso(aresta.inversa()), "Aresta inversa deve ser igual Ã  aresta original invertida");
    }
}



================================================
File: src/test/java/DigrafoTest.java
================================================
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.Parameter;
import org.junit.jupiter.params.ParameterizedClass;
import org.junit.jupiter.params.provider.MethodSource;

import grafo.Aresta;
import grafo.Vertice;
import grafo.digrafo.Digrafo;

@ParameterizedClass
@MethodSource("Provider#digrafos")
public class DigrafoTest {
	@Parameter
	Digrafo grafo;

	@BeforeEach
	void beforeEach() {
		grafo.resetar();
	}

	@Test
	void getGrauDeEntradaESaidaTest() {

		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));
		Vertice verticeD = grafo.addVertice(new Vertice("D"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);

		grafo.addArestas(arestaAB, arestaBC);

		assertEquals(0, grafo.getGrauDeEntrada(verticeA), "Grau de entrada do vÃ©rtice A deve ser 0");
		assertEquals(1, grafo.getGrauDeSaida(verticeA), "Grau de saÃ­da do vÃ©rtice A deve ser 1");

		assertEquals(1, grafo.getGrauDeEntrada(verticeB), "Grau de entrada do vÃ©rtice B deve ser 1");
		assertEquals(1, grafo.getGrauDeSaida(verticeB), "Grau de saÃ­da do vÃ©rtice B deve ser 1");

		assertEquals(1, grafo.getGrauDeEntrada(verticeC), "Grau de entrada do vÃ©rtice C deve ser 1");
		assertEquals(0, grafo.getGrauDeSaida(verticeC), "Grau de saÃ­da do vÃ©rtice C deve ser 0");

		assertEquals(0, grafo.getGrauDeEntrada(verticeD), "Grau de entrada do vÃ©rtice D deve ser 0");
		assertEquals(0, grafo.getGrauDeSaida(verticeD), "Grau de saÃ­da do vÃ©rtice D deve ser 0");
	}

	@Test
	void getArestasTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));

		Aresta arestaAB1 = new Aresta("AB", verticeA, verticeB);
		Aresta arestaAB2 = arestaAB1.comLabel("AB2");
		Aresta arestaBA = arestaAB1.inversa().comLabel("BA");
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);

		grafo.addArestas(arestaAB1, arestaAB2, arestaBA, arestaBC);

		Set<Aresta> arestas = grafo.getArestas();
		assertEquals(4, arestas.size(), "O grafo deve ter 4 arestas.");
		assertEquals(2, grafo.encontrarArestas(verticeA, verticeB).size(),
				"O grafo deve ter 2 arestas AB.");
		assertEquals(1, grafo.encontrarArestas(verticeB, verticeA).size(),
				"O grafo deve ter 1 aresta BA.");
		assertEquals(1, grafo.encontrarArestas(verticeB, verticeC).size(), "O grafo deve ter 1 aresta BC.");
	}

}



================================================
File: src/test/java/FleuryTest.java
================================================
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.Parameter;
import org.junit.jupiter.params.ParameterizedClass;
import org.junit.jupiter.params.provider.MethodSource;

import grafo.Aresta;
import grafo.Vertice;
import grafo.nao_orientado.GrafoNaoDirecionado;
import grafo.util.Fleury;

@ParameterizedClass
@MethodSource("Provider#grafosNaoDirecionados")
public class FleuryTest {
    @Parameter
    GrafoNaoDirecionado grafo;

    @BeforeEach
    void beforeEach() {
        grafo.resetar();
    }

    @Test
    void fleuryTest() {
        Vertice verticeA = grafo.addVertice(new Vertice("A"));
        Vertice verticeB = grafo.addVertice(new Vertice("B"));
        Vertice verticeC = grafo.addVertice(new Vertice("C"));
        Vertice verticeD = grafo.addVertice(new Vertice("D"));

        grafo.addArestas(
                new Aresta("AB", verticeA, verticeB),
                new Aresta("BC", verticeB, verticeC),
                new Aresta("CD", verticeC, verticeD),
                new Aresta("DA", verticeD, verticeA),
                new Aresta("AC1", verticeA, verticeC),
                new Aresta("AC2", verticeA, verticeC));

        List<Aresta> caminho = (new Fleury(grafo, verticeA)).getCaminhoEuleriano();

        assertEquals(grafo.getArestas().size(), caminho.size());
    }
}



================================================
File: src/test/java/GrafoNaoDirecionadoTest.java
================================================
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.Parameter;
import org.junit.jupiter.params.ParameterizedClass;
import org.junit.jupiter.params.provider.MethodSource;

import grafo.Aresta;
import grafo.Vertice;
import grafo.nao_orientado.GrafoNaoDirecionado;

@ParameterizedClass
@MethodSource("Provider#grafosNaoDirecionados")
public class GrafoNaoDirecionadoTest {
	@Parameter
	GrafoNaoDirecionado grafo;

	@BeforeEach
	void beforeEach() {
		grafo.resetar();
	}

	@Test
	void addArestaTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);

		grafo.addArestas(arestaAB);

		assertTrue(grafo.existeAresta(verticeA, verticeB), "Aresta entre A e B deve existir");
		assertTrue(grafo.existeAresta(verticeB, verticeA), "Aresta entre B e A deve existir (grafo nÃ£o direcionado)");
	}

	@Test
	void addArestasParalelasTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));

		Aresta arestaAB1 = new Aresta("AB1", verticeA, verticeB);
		Aresta arestaAB2 = arestaAB1.comLabel("AB2");

		grafo.addArestas(arestaAB1, arestaAB2);

		assumeTrue(grafo.encontrarArestas(verticeA, verticeB).size() == 2, "Deve haver duas arestas entre A e B");
		assertEquals(2, grafo.encontrarArestas(verticeB, verticeA).size(), "Deve haver duas arestas entre B e A");
	}

	@Test
	void removeArestaTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);

		grafo.addAresta(arestaAB);

		grafo.removeAresta(verticeA, verticeB);
		assertFalse(grafo.existeAresta(verticeA, verticeB), "Aresta entre A e B nÃ£o deve existir apÃ³s remoÃ§Ã£o");
		assertFalse(grafo.existeAresta(verticeB, verticeA),
				"Aresta entre B e A nÃ£o deve existir apÃ³s remoÃ§Ã£o (grafo nÃ£o direcionado)");
	}

	@Test
	void removeArestasParalelasTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));

		Aresta arestaAB1 = new Aresta("AB", verticeA, verticeB);
		Aresta arestaAB2 = arestaAB1.comLabel("AB2");

		grafo.addArestas(arestaAB1, arestaAB2);

		grafo.removeAresta(verticeA, verticeB);

		assertEquals(1, grafo.encontrarArestas(verticeA, verticeB).size(),
				"Deve haver uma aresta restante entre A e B");
		assertEquals(1, grafo.encontrarArestas(verticeB, verticeA).size(),
				"Deve haver uma aresta restante entre B e A (grafo nÃ£o direcionado)");

		grafo.removeAresta(verticeA, verticeB);

		assertFalse(grafo.existeAresta(verticeA, verticeB), "Aresta entre A e B nÃ£o deve existir apÃ³s remoÃ§Ã£o parcial");
		assertFalse(grafo.existeAresta(verticeB, verticeA),
				"Aresta entre B e A nÃ£o deve existir apÃ³s remoÃ§Ã£o parcial (grafo nÃ£o direcionado)");
	}

	@Test
	void getGrauTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));
		Vertice verticeD = grafo.addVertice(new Vertice("D"));
		Vertice verticeE = grafo.addVertice(new Vertice("E"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);
		Aresta arestaEE = new Aresta("EE", verticeE, verticeE);

		grafo.addArestas(arestaAB, arestaBC, arestaEE);

		assertEquals(1, grafo.getGrau(verticeA), "Grau do vÃ©rtice A deve ser 1");
		assertEquals(2, grafo.getGrau(verticeB), "Grau do vÃ©rtice B deve ser 2");
		assertEquals(1, grafo.getGrau(verticeC), "Grau do vÃ©rtice C deve ser 1");
		assertEquals(0, grafo.getGrau(verticeD), "Grau do vÃ©rtice D deve ser 0");
		assertEquals(2, grafo.getGrau(verticeE), "Grau do vÃ©rtice E deve ser 2 (laÃ§o)");
	}

	@Test
	void getGrauDeEntradaESaidaTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));
		Vertice verticeD = grafo.addVertice(new Vertice("D"));
		Vertice verticeE = grafo.addVertice(new Vertice("E"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);
		Aresta arestaEE = new Aresta("EE", verticeE, verticeE);

		grafo.addArestas(arestaAB, arestaBC, arestaEE);

		assertEquals(grafo.getGrau(verticeA), grafo.getGrauDeEntrada(verticeA),
				"Grau de entrada do vÃ©rtice A deve ser igual ao grau (grafo nÃ£o direcionado)");
		assertEquals(grafo.getGrau(verticeA), grafo.getGrauDeSaida(verticeA),
				"Grau de saÃ­da do vÃ©rtice A deve ser igual ao grau (grafo nÃ£o direcionado)");

		assertEquals(grafo.getGrau(verticeB), grafo.getGrauDeEntrada(verticeB),
				"Grau de entrada do vÃ©rtice B deve ser igual ao grau (grafo nÃ£o direcionado)");
		assertEquals(grafo.getGrau(verticeB), grafo.getGrauDeSaida(verticeB),
				"Grau de saÃ­da do vÃ©rtice B deve ser igual ao grau (grafo nÃ£o direcionado)");

		assertEquals(grafo.getGrau(verticeC), grafo.getGrauDeEntrada(verticeC),
				"Grau de entrada do vÃ©rtice C deve ser igual ao grau (grafo nÃ£o direcionado)");
		assertEquals(grafo.getGrau(verticeC), grafo.getGrauDeSaida(verticeC),
				"Grau de saÃ­da do vÃ©rtice C deve ser igual ao grau (grafo nÃ£o direcionado)");

		assertEquals(grafo.getGrau(verticeD), grafo.getGrauDeEntrada(verticeD),
				"Grau de entrada do vÃ©rtice D deve ser igual ao grau (grafo nÃ£o direcionado)");
		assertEquals(grafo.getGrau(verticeD), grafo.getGrauDeSaida(verticeD),
				"Grau de saÃ­da do vÃ©rtice D deve ser igual ao grau (grafo nÃ£o direcionado)");

		assertEquals(grafo.getGrau(verticeE), grafo.getGrauDeEntrada(verticeE),
				"Grau de entrada do vÃ©rtice E deve ser igual ao grau (grafo nÃ£o direcionado)");
		assertEquals(grafo.getGrau(verticeE), grafo.getGrauDeSaida(verticeE),
				"Grau de saÃ­da do vÃ©rtice E deve ser igual ao grau (grafo nÃ£o direcionado)");
	}

	@Test
	void getArestasTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));

		Aresta arestaAB1 = new Aresta("AB1", verticeA, verticeB);
		Aresta arestaAB2 = arestaAB1.comLabel("AB2");
		Aresta arestaBA = arestaAB1.inversa().comLabel("BA");
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);

		grafo.addArestas(arestaAB1, arestaAB2, arestaBA, arestaBC);

		Set<Aresta> arestas = grafo.getArestas();
		assertEquals(4, arestas.size(), "O grafo deve ter 4 arestas.");

		assertEquals(3, grafo.encontrarArestas(verticeA, verticeB).size(), "Deve haver 3 arestas AB");
		assertEquals(3, grafo.encontrarArestas(verticeB, verticeA).size(), "Deve haver 3 arestas BA");
		assertEquals(1, grafo.encontrarArestas(verticeB, verticeC).size(), "Deve haver uma aresta BC");
		assertEquals(1, grafo.encontrarArestas(verticeC, verticeB).size(), "Deve haver uma aresta CB");
	}

	@Test
	void unirTest() {

		GrafoNaoDirecionado grafo1 = (GrafoNaoDirecionado) grafo.clonar();

		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaBA = arestaAB.inversa();
		grafo.addArestas(arestaAB, arestaBA);

		Vertice verticeC = grafo1.addVertice(new Vertice("C"));
		Vertice verticeD = grafo1.addVertice(new Vertice("D"));
		Aresta arestaCC = new Aresta("CC", verticeC, verticeC);
		grafo1.addArestas(arestaCC);

		GrafoNaoDirecionado grafoUnido = grafo.uniao(grafo1);

		assertTrue(grafoUnido.existeVertice(verticeA), "O vÃ©rtice A deve existir no grafo unido");
		assertTrue(grafoUnido.existeVertice(verticeB), "O vÃ©rtice B deve existir no grafo unido");
		assertTrue(grafoUnido.existeVertice(verticeC), "O vÃ©rtice C deve existir no grafo unido");
		assertTrue(grafoUnido.existeAresta(verticeA, verticeB), "A aresta AB deve existir no grafo unido");
		assertTrue(grafoUnido.existeAresta(verticeB, verticeA), "A aresta BA deve existir no grafo unido");
		assertTrue(grafoUnido.existeAresta(verticeC, verticeC), "A aresta CC deve existir no grafo unido");
	}
}



================================================
File: src/test/java/GrafoTest.java
================================================
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.Parameter;
import org.junit.jupiter.params.ParameterizedClass;
import org.junit.jupiter.params.provider.MethodSource;

import grafo.Aresta;
import grafo.Grafo;
import grafo.Vertice;

@ParameterizedClass
@MethodSource("Provider#grafos")
public class GrafoTest {
	@Parameter
	Grafo grafo;

	@BeforeEach
	void beforeEach() {
		grafo.resetar();
	}

	@Test
	void testResetar() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));

		Aresta arestaAB = new Aresta("AB1", verticeA, verticeB);

		grafo.addArestas(arestaAB, arestaAB.comLabel("AB2"));

		assumeTrue(!grafo.getArestas().isEmpty(), () -> String
				.format("O grafo deve possuir arestas antes de resetar. Tem %d arestas.", grafo.getArestas().size()));
		assumeTrue(!grafo.getVertices().isEmpty(), () -> String
				.format("O grafo deve possuir vÃ©rtices antes de resetar. Tem %d vÃ©rtices.", grafo.getVertices()
																								 .size()));

		grafo.resetar();

		assertEquals(0, grafo.getVertices().size(), "O grafo deve ter zero vÃ©rtices apÃ³s resetar");
		assertEquals(0, grafo.getArestas().size(), "O grafo deve ter zero arestas apÃ³s resetar");
	}

	@Test
	void testQuantidadeDeVertices() {
		grafo.addVertices(new Vertice("A"), new Vertice("B"));

		assertEquals(2, grafo.getVertices().size(), "O grafo deve ter 2 vÃ©rtices.");
	}

	@Test
	void testQuantidadeDeArestas() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));

		Aresta arestaAB = new Aresta("AB1", verticeA, verticeB);

		grafo.addArestas(arestaAB, arestaAB.comLabel("AB2"));

		assertEquals(2, grafo.getArestas().size(), "O grafo deve ter 2 arestas.");
	}

	@Test
	void getArestasTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));

		Aresta arestaAB1 = new Aresta("AB", verticeA, verticeB);
		Aresta arestaAB2 = arestaAB1.comLabel("AB2");
		Aresta arestaBA = arestaAB1.inversa().comLabel("BA");
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);

		grafo.addArestas(arestaAB1, arestaAB2, arestaBA, arestaBC);

		Set<Aresta> arestas = grafo.getArestas();
		assertEquals(4, arestas.size(), "O grafo deve ter 4 arestas.");
	}

	void addVerticeTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));

		assertTrue(grafo.existeVertice(verticeA), "VÃ©rtice A deve existir");
		assertTrue(grafo.existeVertice(verticeB), "VÃ©rtice B deve existir");
		assertFalse(grafo.existeVertice(verticeC), "VÃ©rtice C nÃ£o deve existir");
	}

	@Test
	void addVerticeViaArestaTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);

		grafo.addAresta(arestaAB);

		assertTrue(grafo.existeVertice(verticeA), "VÃ©rtice A deve existir");
		assertTrue(grafo.existeVertice(verticeB), "VÃ©rtice B deve existir");
	}

	@Test
	void addArestaTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));
		Vertice verticeD = grafo.addVertice(new Vertice("D"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaCD = new Aresta("CD", verticeC, verticeD);
		Aresta arestaAC = new Aresta("AC", verticeA, verticeC);

		grafo.addArestas(arestaAB, arestaCD, arestaAC);

		assertTrue(grafo.existeAresta(verticeA, verticeB), "Aresta entre A e B deve existir");
		assertTrue(grafo.existeAresta(verticeC, verticeD), "Aresta entre C e D deve existir");
		assertTrue(grafo.existeAresta(verticeA, verticeC), "Aresta entre A e C deve existir");
	}

	@Test
	void addArestasParalelasTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));

		Aresta arestaAB = new Aresta("AB1", verticeA, verticeB);

		grafo.addArestas(arestaAB, arestaAB.comLabel("AB2"));

		assertEquals(2, grafo.encontrarArestas(verticeA, verticeB).size(), "Deve haver duas arestas entre A e B");
	}

	@Test
	void removeArestaTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);

		grafo.addAresta(arestaAB);

		grafo.removeAresta(verticeA, verticeB);
		assertFalse(grafo.existeAresta(verticeA, verticeB), "Aresta entre A e B nÃ£o deve existir apÃ³s remoÃ§Ã£o");
	}

	@Test
	void removeArestasParalelasTest() {
		Vertice verticeA = new Vertice("A");
		Vertice verticeB = new Vertice("B");

		Aresta arestaAB1 = new Aresta("AB1", verticeA, verticeB);
		Aresta arestaAB2 = new Aresta("AB2", verticeA, verticeB);

		grafo.addArestas(arestaAB1, arestaAB2);

		grafo.removeAresta(verticeA, verticeB);

		assertEquals(1, grafo.encontrarArestas(verticeA, verticeB).size(),
				"Deve haver uma aresta restante entre A e B");

		grafo.removeAresta(verticeA, verticeB);

		assertFalse(grafo.existeAresta(verticeA, verticeB), "Aresta entre A e B nÃ£o deve existir apÃ³s remoÃ§Ã£o total");
	}

	@Test
	void getConectadosTest() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));
		Vertice verticeD = grafo.addVertice(new Vertice("D"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);
		Aresta arestaCD = new Aresta("CD", verticeC, verticeD);
		Aresta arestaDA = new Aresta("DA", verticeD, verticeA);
		Aresta arestaAC1 = new Aresta("AC1", verticeA, verticeC);
		Aresta arestaAC2 = new Aresta("AC2", verticeA, verticeC);


		grafo.addArestas(arestaAB, arestaBC, arestaCD, arestaDA, arestaAC1, arestaAC2);

		Set<Vertice> conectadosA = grafo.getConectados(verticeA);
		Set<Vertice> conectadosB = grafo.getConectados(verticeB);
		Set<Vertice> conectadosC = grafo.getConectados(verticeC);
		Set<Vertice> conectadosD = grafo.getConectados(verticeD);

		assertEquals(Set.of(verticeB, verticeC, verticeD), conectadosA,
				"VÃ©rtices conectados a A devem incluir B, C e D");
		assertEquals(Set.of(verticeA, verticeC), conectadosB,
				"VÃ©rtices conectados a B devem incluir A e C");
		assertEquals(Set.of(verticeA, verticeB, verticeD), conectadosC,
				"VÃ©rtices conectados a C devem incluir A, B e D");
		assertEquals(Set.of(verticeA, verticeC), conectadosD,
				"VÃ©rtices conectados a D devem incluir A e C");
	}

	@Test
	void clonarTest() {
		Vertice verticeA = new Vertice("A");
		Vertice verticeB = new Vertice("B");
		Vertice verticeC = new Vertice("C");
		Vertice verticeD = new Vertice("D");

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);
		Aresta arestaDD = new Aresta("DD", verticeD, verticeD);

		grafo.addArestas(arestaAB, arestaAB.inversa(), arestaBC, arestaDD);

		Grafo clone = grafo.clonar();

		assertNotSame(grafo, clone, "O clone nÃ£o deve ser o mesmo objeto");
		assertEquals(grafo, clone);
		assertEquals(grafo.getVertices().size(), clone.getVertices().size(), "O nÃºmero de vÃ©rtices deve ser igual");
		assertEquals(grafo.getArestas().size(), clone.getArestas().size(), "O nÃºmero de arestas deve ser igual");

		assertTrue(clone.existeAresta(verticeA, verticeB), "O clone deve conter a aresta original");
		assertTrue(clone.existeAresta(verticeB, verticeA), "O clone deve conter a aresta inversa");
		assertTrue(clone.existeAresta(verticeB, verticeC), "O clone deve conter a aresta BC");
		assertTrue(clone.existeAresta(verticeD, verticeD), "O clone deve conter a aresta DD");
		assertTrue(clone.existeVertice(verticeA), "O clone deve conter o vÃ©rtice A");
		assertTrue(clone.existeVertice(verticeB), "O clone deve conter o vÃ©rtice B");
		assertTrue(clone.existeVertice(verticeC), "O clone deve conter o vÃ©rtice C");
		assertTrue(clone.existeVertice(verticeD), "O clone deve conter o vÃ©rtice D");

		assertEquals(Set.of(arestaAB, arestaAB.inversa(), arestaBC, arestaDD), clone.getArestas());
		assertEquals(Set.of(verticeA, verticeB, verticeC, verticeD), clone.getVertices(),
				"O clone deve conter os mesmos vÃ©rtices");
	}

	@Test
	void ehDisjuntoTest() {
		Grafo grafo1 = grafo.clonar();
		Grafo grafo2 = grafo.clonar();
		Grafo grafo3 = grafo.clonar();

		grafo1.addArestas(
				new Aresta("AB", new Vertice("A"), new Vertice("B")),
				new Aresta("BC", new Vertice("B"), new Vertice("C"))
		);

		grafo2.addArestas(
				new Aresta("DE", new Vertice("D"), new Vertice("E")),
				new Aresta("EF", new Vertice("E"), new Vertice("F"))
		);

		grafo3.addArestas(
				new Aresta("AH", new Vertice("A"), new Vertice("H")),
				new Aresta("HI", new Vertice("H"), new Vertice("I"))
		);

		assertTrue(grafo1.ehDisjunto(grafo2), "Grafo 1 e Grafo 2 devem ser disjuntos");
		assertFalse(grafo1.ehDisjunto(grafo3), "Grafo 1 e Grafo 3 nÃ£o devem ser disjuntos");
		assertTrue(grafo2.ehDisjunto(grafo3), "Grafo 2 e Grafo 3 devem ser disjuntos");
	}

	@Test
	void ehConexoTest() {
		Grafo grafoConexo = grafo.clonar();
		Grafo grafoNaoConexo = grafo.clonar();
		Grafo grafoNaoConexo2 = grafo.clonar();

		grafoConexo.addArestas(
				new Aresta("AB", new Vertice("A"), new Vertice("B")),
				new Aresta("BC", new Vertice("B"), new Vertice("C")),
				new Aresta("CA", new Vertice("C"), new Vertice("A"))
		);

		grafoNaoConexo.addArestas(
				new Aresta("AB", new Vertice("A"), new Vertice("B")),
				new Aresta("CD", new Vertice("C"), new Vertice("D"))
		);

		grafoNaoConexo2.addArestas(
				new Aresta("AB", new Vertice("A"), new Vertice("B"))
		);
		grafoNaoConexo2.addVertices(new Vertice("C"));

		assertTrue(grafoConexo.ehConexo(), "Grafo conexo deve ser conexo");
		assertFalse(grafoNaoConexo.ehConexo(), "Grafo nÃ£o conexo nÃ£o deve ser conexo");
		assertFalse(grafoNaoConexo2.ehConexo(), "Grafo nÃ£o conexo 2 nÃ£o deve ser conexo");
	}

	@Test
	void ehPonteTest() {
		Aresta arestaAB1 = new Aresta("AB1", new Vertice("A"), new Vertice("B"));
		Aresta arestaAB2 = new Aresta("AB2", new Vertice("A"), new Vertice("B"));
		Aresta arestaBC = new Aresta("BC", new Vertice("B"), new Vertice("C"));

		grafo.addArestas(arestaAB1, arestaAB2, arestaBC);

		assertFalse(grafo.ehPonte(arestaAB1), "A aresta AB1 nÃ£o deve ser uma ponte, pois hÃ¡ outra aresta AB2");
		assertFalse(grafo.ehPonte(arestaAB2), "A aresta AB2 nÃ£o deve ser uma ponte, pois hÃ¡ outra aresta AB1");
		assertTrue(grafo.ehPonte(arestaBC), "A aresta BC deve ser uma ponte, pois Ã© a Ãºnica entre B e C");
	}

	@Test
	void ehPonte2Test() {
		Vertice verticeA = grafo.addVertice(new Vertice("A"));
		Vertice verticeB = grafo.addVertice(new Vertice("B"));
		Vertice verticeC = grafo.addVertice(new Vertice("C"));
		Vertice verticeD = grafo.addVertice(new Vertice("D"));

		Aresta arestaAB = new Aresta("AB", verticeA, verticeB);
		Aresta arestaBC = new Aresta("BC", verticeB, verticeC);
		Aresta arestaCD = new Aresta("CD", verticeC, verticeD);
		Aresta arestaDA = new Aresta("DA", verticeD, verticeA);
		Aresta arestaAC1 = new Aresta("AC1", verticeA, verticeC);
		Aresta arestaAC2 = new Aresta("AC2", verticeA, verticeC);


		grafo.addArestas(arestaAB, arestaBC, arestaCD, arestaDA, arestaAC1, arestaAC2);

		assertFalse(grafo.ehPonte(arestaAB), "Aresta AB nÃ£o deve ser uma ponte, pois hÃ¡ outras conexÃµes");
		assertFalse(grafo.ehPonte(arestaBC), "Aresta BC nÃ£o deve ser uma ponte, pois hÃ¡ outras conexÃµes");
		assertFalse(grafo.ehPonte(arestaCD), "Aresta CD nÃ£o deve ser uma ponte, pois hÃ¡ outras conexÃµes");
		assertFalse(grafo.ehPonte(arestaDA), "Aresta DA nÃ£o deve ser uma ponte, pois hÃ¡ outras conexÃµes");
		assertFalse(grafo.ehPonte(arestaAC1), "Aresta AC1 nÃ£o deve ser uma ponte, pois hÃ¡ outras conexÃµes");
		assertFalse(grafo.ehPonte(arestaAC2), "Aresta AC2 nÃ£o deve ser uma ponte, pois hÃ¡ outras conexÃµes");
	}
}



================================================
File: src/test/java/MainTest.java
================================================
import grafo.Main;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;

public class MainTest {
	@Test
	void testMain() {
		assertDoesNotThrow(() -> Main.main(null), "Main method should run without exceptions");
	}
}



================================================
File: src/test/java/Provider.java
================================================
import java.util.stream.Stream;

import grafo.Grafo;
import grafo.digrafo.Digrafo;
import grafo.digrafo.DigrafoPorLista;
import grafo.nao_orientado.GrafoNaoDirecionado;
import grafo.nao_orientado.GrafoNaoDirecionadoPorLista;

public abstract class Provider {
    public static Stream<Digrafo> digrafos() {
        return Stream.of(new DigrafoPorLista());
    }

    public static Stream<GrafoNaoDirecionado> grafosNaoDirecionados() {
        return Stream.of(new GrafoNaoDirecionadoPorLista());
    }

    public static Stream<Grafo> grafos() {
        return Stream.concat(digrafos(), grafosNaoDirecionados());
    }

}



================================================
File: src/test/java/VerticeTest.java
================================================
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;

import grafo.Vertice;

public class VerticeTest {
    @Test
    void criarVerticeTest() {
        assertThrows(IllegalArgumentException.class, () -> {
            new Vertice("");
        }, "Deveria lanÃ§ar IllegalArgumentException para vÃ©rtice com label vazio");
        assertThrows(IllegalArgumentException.class, () -> {
            new Vertice(null);
        }, "Deveria lanÃ§ar IllegalArgumentException para vÃ©rtice com label nulo");
    }
}


